<<<<<<< SEARCH
        # Inject Imports if missing
        import_stmt = "from aria.logic.dsl import filter_list, is_even, is_positive, logical_and, logical_or"
        if "from aria.logic.dsl" not in source:
             import_node = ast.parse(import_stmt).body[0]
             tree.body.insert(0, import_node)

        class CodeReplaced(ast.NodeTransformer):
            def visit_FunctionDef(self, node):
                if node.name == function_name:
                    # Replace the entire body with: return <evolved_code>
                    new_body = [ast.Return(value=ast.parse(evolved_code).body[0].value)]
                    node.body = new_body
                    print(f"RSI: Function '{function_name}' body replaced in AST.")
                return node

        new_tree = CodeReplaced().visit(tree)
        ast.fix_missing_locations(new_tree)
=======
        # Inject Imports if missing - comprehensive list
        # We use a wildcard import to ensure all primitives are available for the evolved code
        import_stmt = "from aria.logic.dsl import *"
        has_import = False
        for node in tree.body:
            if isinstance(node, ast.ImportFrom) and node.module == 'aria.logic.dsl':
                has_import = True
                break

        if not has_import:
             import_node = ast.parse(import_stmt).body[0]
             tree.body.insert(0, import_node)

        # Verify evolved code syntax
        try:
            evolved_ast = ast.parse(evolved_code)
        except SyntaxError as e:
            self.logger.error(f"RSI: Evolved code has syntax error: {e}")
            return False

        class CodeReplaced(ast.NodeTransformer):
            def visit_FunctionDef(self, node):
                if node.name == function_name:
                    # Replace the entire body with: return <evolved_code>
                    # We wrap in a return statement
                    if isinstance(evolved_ast.body[0], ast.Expr):
                        ret_val = evolved_ast.body[0].value
                    else:
                        ret_val = evolved_ast.body[0] # Fallback

                    new_body = [ast.Return(value=ret_val)]
                    node.body = new_body
                    print(f"RSI: Function '{function_name}' body replaced in AST.")
                return node

        new_tree = CodeReplaced().visit(tree)
        ast.fix_missing_locations(new_tree)
>>>>>>> REPLACE
